# 算法时间复杂度

衡量算法的性能的好坏，可以使用时间时间复杂度

**度量** 一个程序（算法）执行时间的两种方法：

- 事后统计法

  简单说：就是把程序运行起来，然后查看运行完成的总时间。

  但是有一个问题：所统计的时间，依赖于计算机的硬件、软件等环境因素。如果要使用这种方式，需要在同一台计算机相同状态下运行程序，才能比较哪个算法速度更快

- 事前估算法

  通过分析某个 **算法的时间复杂度** 来判断哪个算法更优

## 时间频度

一个算法 **花费的时间** 与算法中 **语句的执行次数** 成正比，哪个算法中语句执行次数多，它花费时间就多。一个算法中的 **语句执行次数称为语句频度或时间频度**。**记为 `T(n)`**

### 举例-基本案例

计算 1-100 所有数字之和，下面有两种算法：

- 算法 1：循环累加

  ```java
  int total = 0;
  int end = 100;
  // 使用 for 循环计算
  for(int i = 1; i<= end; i++){
    total += i
  }
  ```

  `T(n) = n + 1`，这里的 `n=100`，因为要循环 100 次，还有一次，是跳出循环的判断

- 算法 2：直接计算

  ```java
  total = (1+end) * end/2;
  ```

  `T(n) = 1`

对于时间频度，有如下几个方面可以忽略

### 忽略常数项

| n    | `T(n)=2*n+20` | `T(n)=2*n` | `T(3*n+10)` | T(3*n) |
| ---- | ------------- | ---------- | ----------- | ------ |
| 1    | 22            | 2          | 13          | 3      |
| 2    | 24            | 4          | 16          | 6      |
| 5    | 30            | 10         | 25          | 15     |
| 8    | 36            | 16         | 34          | 24     |
| 15   | 50            | 30         | 55          | 45     |
| 30   | 80            | 60         | 100         | 90     |
| 100  | 220           | 200        | 310         | 300    |
| 300  | 620           | 600        | 910         | 900    |

上表对应的曲线图如下

![image-20200816230100524](./assets/image-20200816230100524.png)

结论：

- `2n+20` 和 2n 随着 n 变大，执行曲线无限接近， 20 可以忽略
- `3n+10` 和 3n 随着 n 变大，执行曲线无限接近，10 可以忽略

### 忽略低次项

| n    | `T(n)=2n^2+3n+10` | `T(2n^2)` | `T(n^2+5n+20)` | T(n^2) |
| ---- | ----------------- | --------- | -------------- | ------ |
| 1    | 15                | 2         | 26             | 1      |
| 2    | 24                | 8         | 34             | 4      |
| 5    | 75                | 50        | 70             | 25     |
| 8    | 162               | 128       | 124            | 64     |
| 15   | 505               | 450       | 320            | 225    |
| 30   | 1900              | 1800      | 1070           | 900    |
| 100  | 20310             | 20000     | 10520          | 10000  |

![image-20200816230724232](./assets/image-20200816230724232.png)

- `2n^2+3n+10` 和 `2n^2` 随着 n 变大，执行曲线无限接近，可以忽略 `3n+10`

-  `n^2+5n+20` 和 `n^2` 随着 n 变大，执行曲线无限接近，可以忽略 `5n+20`

### 忽略系数

| n    | `T(3n^2+2n)` | `T(5n^2+7n)` | `T(n^3+5n)` | `T(6n^3+4n)` |
| ---- | ------------ | ------------ | ----------- | ------------ |
| 1    | 5            | 12           | 6           | 10           |
| 2    | 16           | 34           | 18          | 56           |
| 5    | 85           | 160          | 150         | 770          |
| 8    | 208          | 376          | 552         | 3104         |
| 15   | 705          | 1230         | 3450        | 20310        |
| 30   | 2760         | 4710         | 27150       | 162120       |
| 100  | 30200        | 50700        | 1000500     | 6000400      |

![image-20200816231058264](./assets/image-20200816231058264.png)

结论：

- 随着 n 值变大，`5n^2+7n` 和 `3n^2 + 2n` ，执行曲线重合, 说明：这种情况下， 5 和 3 可以忽略

  对于 2 次方来说，数量级很大的情况下，系数不是很重要（笔者怎么觉得相差也挺多的？是在对于后面更大的来说，看起来重合了而已）

- 而 `n^3+5n` 和 `6n^3+4n`  ，执行曲线分离，说明 **多少次方是关键**

  对于 3 次方来说，系数就不能省略了，这里笔者还是觉得，系数并不能忽略把。

### 小节

时间频度计算还与以下三个统计注意事项：

- 忽略常数项

  - `2n+20` 和 2n 随着 n 变大，执行曲线无限接近， 20 可以忽略
  - `3n+10` 和 3n 随着 n 变大，执行曲线无限接近，10 可以忽略

- 忽略低次项

  - `2n^2+3n+10` 和 `2n^2` 随着 n 变大，执行曲线无限接近，可以忽略 `3n+10`

  - `n^2+5n+20` 和 `n^2` 随着 n 变大，执行曲线无限接近，可以忽略 `5n+20`

- 忽略系数

  - 随着 n 值变大，`5n^2+7n` 和 `3n^2 + 2n` ，执行曲线重合, 说明：这种情况下， 5 和 3 可以忽略

    对于 2 次方来说，数量级很大的情况下，系数不是很重要（笔者怎么觉得相差也挺多的？是在对于后面更大的来说，看起来重合了而已）

  - 而 `n^3+5n` 和 `6n^3+4n`  ，执行曲线分离，说明 **多少次方是关键**

    对于 3 次方来说，系数就不能省略了，次方越大，系数也越大的时候，相差其实是很大的